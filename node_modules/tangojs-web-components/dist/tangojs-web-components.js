
  if (!window.tangojs) {
    throw new Error('tangojs.core not loaded!')
  }
  
this.tangojs = this.tangojs || {};
(function (exports) {
  'use strict';

  /**
   * Adds support for periodically polled model(s).
   *
   * Prototype that mixes this in should expose following functions:
   * - onModelRead  {function(resultMap: Object): undefined}
   * - onModelError {function(error: Object): undefined}
   * - createProxy  {function(model: string): (AttributeProxy|DeviceProxy)}
   * - readProxy    {function(proxy: (AttributeProxy|DeviceProxy)):
   *                  (DeviceAttribute|DevState)}
   *
   * Following functions and properties are added:
   * - proxy {Object}
   * - onModelChange {function(model: string): undefined}
   * - onPollPeriodChange {function(pollPeriod: number): undefined}
   * - restartPollingTimer {function(): undefined}
   */
  function withPolledModel () {

    const timer = Symbol.for('timer')
    const proxy = Symbol.for('proxy')

    if (!this.createProxy) {
      console.warn(`Mixing prototype lacks 'createProxy' method.`)
    }

    if (!this.readProxy) {
      console.warn(`Mixing prototype lacks 'readProxy' method.`)
    }

    if (!this.onModelRead) {
      this.onModelRead = function () {}
    }

    if (!this.onModelError) {
      this.onModelError = function (error) {
        console.error(error)
      }
    }

    Object.defineProperty(this, 'proxy', {
      configurable: false,
      get: function () { return this[proxy] }
    })

    this.onModelChange = function (model) {
      this[proxy] = (Array.isArray(model) ? model : [model])
        .reduce((p, m) => (p[m] = this.createProxy(m), p), {})
      this.restartPollingTimer()
    }

    this.onPollPeriodChange = function (pollPeriod) {
      this.restartPollingTimer()
    }

    this.restartPollingTimer = function () {

      if (this[timer]) {
        clearInterval(this[timer])
      }

      this[timer] = setInterval(() => {

        const promisedResults = Object
          .keys(this[proxy])
          .map(m => this.readProxy(this[proxy][m]).then(x => [m, x]))

        Promise.all(promisedResults)
          .then(results => {
            const resultsMap = results.reduce(
              (acc, [m, x]) => (acc[m] = x, acc),
              {})
            this.onModelRead(resultsMap)
          })
          .catch(error => {
            this.onModelError(error)
          })
      }, this.pollPeriod) // FIXME: poolPeriod may be stored in mixin closure.
    }

  }

  /**
   * Conversion functions between IDL attributes and content attributes.
   * @see https://html.spec.whatwg.org/multipage/infrastructure.html#reflecting-content-attributes-in-idl-attributes
   */

  /*
   * For simplicity we assume that there are five data types:
   * - Number
   * - String
   * - Boolean
   * - Array (containing data of types shown above)
   * - Object (everything else)
   *
   * Object type cannot be converted.
   *
   * IDL attribute is a Javascript entity, backed by content attribute.
   * Content attribute is a plain-old javascript string.
   */

  const stringIdentity = x => `${x}`

  const jsonParse = x => JSON.parse(x)
  const jsonStringify = x => JSON.stringify(x)

  const arrayParse = (x, elemParse) => x.split(',').map(e => elemParse(e.trim()))
  const arrayStringify = (x, elemStringify) => x.map(elemStringify).join(',')

  const booleanParse = x => x !== null
  const booleanStringify = x => ''

  const normalizeType = type => {
    if (Array.isArray(type)) {
      return type.map(normalizeType)
    } else {
      switch (type) {
        case Array:
        case 'Array':
        case 'array': return Array
        case Number:
        case 'Number':
        case 'number': return Number
        case Boolean:
        case 'Boolean':
        case 'boolean': return Boolean
        case String:
        case 'String':
        case 'string': return String
      }
      throw new Error(`Unsupported type ${type}.`)
    }
  }

  function getConvertToAttribute (type) {
    const ntype = normalizeType(type)
    if (Array.isArray(ntype) && ntype[0] === Array) {
      return x => arrayStringify(x, getConvertToAttribute(ntype[1]))
    } else {
      switch (ntype) {
        case Number: return jsonStringify
        case Boolean: return booleanStringify
        case String: return stringIdentity
      }
      throw new Error(`No converter found for ${ntype} type.`)
    }
  }

  function getConvertFromAttribute (type) {
    const ntype = normalizeType(type)
    if (Array.isArray(ntype) && ntype[0] === Array) {
      return x => arrayParse(x, getConvertFromAttribute(ntype[1]))
    } else {
      switch (ntype) {
        case Number: return jsonParse
        case Boolean: return booleanParse
        case String: return stringIdentity
      }
      throw new Error(`No converter found for ${ntype} type.`)
    }
  }

  function getDefaultValue (type) {
    const ntype = normalizeType(type)
    if (Array.isArray(ntype) && ntype[0] === Array) {
      return []
    } else {
      switch (ntype) {
        case Number: return 0
        case Boolean: return false
        case String: return ''
      }
      throw new Error(`No default value found for ${ntype} type.`)
    }
  }


  var converters = Object.freeze({
    getConvertToAttribute: getConvertToAttribute,
    getConvertFromAttribute: getConvertFromAttribute,
    getDefaultValue: getDefaultValue
  });

  /**
   * Adds Javascript property that reflects DOM attribute.
   * @param {Object}                         descriptor
   * @param {string}                         descriptor.attributeName
   * @param {string}                         descriptor.reflectedName
   * @param {Function|string}                descriptor.type
   * @param {Object}                         descriptor.defaultValue
   * @param {function(t: Object): undefined} descriptor.onChange
   */
  function withReflectedAttribute ({attributeName,
                                                   reflectedName,
                                                   type,
                                                   defaultValue,
                                                   onChange}) {

    const toAttribute = getConvertToAttribute(type)
    const fromAttribute = getConvertFromAttribute(type)

    const createdCallback = this.createdCallback || (() => {})
    const attributeChangedCallback = this.attributeChangedCallback || (() => {})

    const onChangeCallback = onChange || (() => {})

    if (!defaultValue && defaultValue !== false) {
      defaultValue = getDefaultValue(type)
    }

    if (type === Boolean || type === 'boolean' || type === 'Boolean') {
      Object.defineProperty(this, reflectedName, {
        configurable: false,
        get: function () {
          return this.hasAttribute(attributeName)
        },
        set: function (value) {
          if (value === true) {
            this.setAttribute(attributeName, '')
          } else {
            this.removeAttribute(attributeName)
          }
        }
      })
    } else {
      Object.defineProperty(this, reflectedName, {
        configurable: false,
        get: function () {
          const value = this.getAttribute(attributeName)
          if (value !== null) {
            return fromAttribute(value)
          } else {
            return defaultValue
          }
        }, set: function (value) {
          this.setAttribute(attributeName, toAttribute(value))
        }
      })
    }

    this.createdCallback = function () {
      createdCallback.call(this)
      onChangeCallback.call(this, this[reflectedName])
    }

    this.attributeChangedCallback = function (localName, oldValue, newValue) {
      if (localName === attributeName) {
        onChangeCallback.call(this, this[reflectedName])
      }
      attributeChangedCallback.call(this, localName, oldValue, newValue)
    }

  }

  /**
   * @typedef {Object} ComponentCapabilities
   * @property {boolean} multipleModels supports multiple models?
   * @property {boolean} attributes     supports attributes?
   * @property {boolean} commands       supports commands?
   * @property {boolean} status         supports status-fields?
   * @property {boolean} readOnly       supports read-only attributes?
   */

  /**
   * @typedef {Object} ComponentDescriptor
   * @property {string}                tag          tag name
   * @property {ComponentCapabilities} capabilities supported caps.
   */

  /**
   * Registers custom element as a TangoJS component.
   * @param {string}                 tagName
   * @param {Object}                 constructor
   * @param {?ComponentCapabilities} capabilities
   * @param {Object}                 attributes
   */
  function registerComponent (tagName,
                                     constructor,
                                     capabilities = {},
                                     attributes = {}) {

    const registeredConstructor = window.document.registerElement(tagName, {
      prototype: constructor.prototype
    })

    Object.defineProperty(registeredConstructor, 'descriptor', {
      value: {
        tag: tagName,
        capabilities,
        attributes
      }
    })

    components[constructor.name] = registeredConstructor
  }

  /**
   * Returns owner document of current script.
   * @return {HTMLDocument}
   */
  function getCurrentDocument () {
    const document = window.document
    const currentScript = (document._currentScript || document.currentScript)
    return currentScript.ownerDocument
  }

  /**
   * Loads stylesheet from external HTML file.
   * @param {string} styleModuleId
   * @param {?string} stylesheetId
   * @return {HTMLStyleElement}
   */
  function importStyleModule (styleModuleId, stylesheetId) {
    const currentDocument = getCurrentDocument()
    const styleModule = currentDocument.getElementById(styleModuleId).import
    const style = stylesheetId
      ? styleModule.getElementById(stylesheetId)
      : styleModule.querySelector('style')
    return currentDocument.importNode(style, true)
  }

  function hypenatedForm (s) {
    return s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()
  }

  function camelCasedForm (s) {
    return s.replace(/-([a-z])/g, (g) => g[1].toUpperCase())
  }


  var helpers = Object.freeze({
    registerComponent: registerComponent,
    getCurrentDocument: getCurrentDocument,
    importStyleModule: importStyleModule,
    hypenatedForm: hypenatedForm,
    camelCasedForm: camelCasedForm
  });

  /**
   * Applies withReflectedAttribute muliple times.
   * @param {Object} descriptors
   */
  function withReflectedAttributes (descriptorMap) {

    Object.keys(descriptorMap).forEach(reflectedName => {
      const newDescriptor = Object.assign(
        {},
        descriptorMap[reflectedName],
        {
          reflectedName,
          attributeName: hypenatedForm(reflectedName)
        })
      withReflectedAttribute.call(this, newDescriptor)
    })
  }

  /**
   * Various functional operations.
   */

  /**
   * @param {Array<T>} array
   * @param {function(t: T): V} fn
   * @return {Array<[V, Array<T>]}
   */
  function groupBy (array, fn) {
    const map =  array.reduce((grouped, element) => {
      const key = fn(element)
      if (!grouped.has(key)) {
        grouped.set(key, [])
      }
      grouped.get(key).push(element)
      return grouped
    }, new Map())
    return [...map]
  }


  var fn = Object.freeze({
    groupBy: groupBy
  });

  /**
   * Container for registered components.
   */
  const components = { }


  /**
   * Utility functions for components
   */
  const util = Object.assign(
    {},
    helpers,
    { fn },
    { converters },
    {
      mixins: {
        withPolledModel,
        withReflectedAttribute,
        withReflectedAttributes
      }
    })

  exports.components = components;
  exports.util = util;

}((this.tangojs.web = this.tangojs.web || {})));
//# sourceMappingURL=tangojs-web-components.js.map